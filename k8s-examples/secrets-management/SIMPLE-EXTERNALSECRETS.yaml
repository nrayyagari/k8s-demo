# SIMPLE EXTERNAL SECRETS: Start Here
# Basic external secrets setup using External Secrets Operator (ESO)

---
# 1. Create namespace for external secrets demo
apiVersion: v1
kind: Namespace
metadata:
  name: external-secrets-demo
  labels:
    purpose: learning-external-secrets

---
# 2. Create a mock external secret store using a ConfigMap
# In production, this would be AWS Secrets Manager, Vault, etc.
apiVersion: v1
kind: ConfigMap
metadata:
  name: mock-secret-store
  namespace: external-secrets-demo
data:
  # Simulate external secrets (normally these would be in Vault/AWS/etc.)
  database-password: "super-secret-db-password-123"
  api-key: "sk-1234567890abcdef"
  oauth-client-secret: "oauth-secret-xyz789"
  database-url: "postgresql://user:password@db.company.com:5432/appdb"

---
# 3. ServiceAccount for External Secrets Operator
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-secrets-sa
  namespace: external-secrets-demo
  labels:
    app: external-secrets

---
# 4. ClusterRole for External Secrets (minimal permissions for demo)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-secrets-demo-role
rules:
- apiGroups: [""]
  resources: ["secrets", "configmaps"]
  verbs: ["get", "list", "create", "update", "patch", "delete"]
- apiGroups: ["external-secrets.io"]
  resources: ["externalsecrets", "secretstores", "clustersecretstores"]
  verbs: ["get", "list", "watch"]

---
# 5. ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: external-secrets-demo-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-secrets-demo-role
subjects:
- kind: ServiceAccount
  name: external-secrets-sa
  namespace: external-secrets-demo

---
# 6. SecretStore - Configuration for accessing external secrets
# This uses Kubernetes provider (for demo), but normally would be AWS/Vault/etc.
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: demo-secret-store
  namespace: external-secrets-demo
spec:
  provider:
    # Using Kubernetes provider for demo (accesses ConfigMaps as "external" secrets)
    kubernetes:
      # Remote cluster configuration (using same cluster for demo)
      remoteNamespace: external-secrets-demo
      server:
        caProvider:
          type: ConfigMap
          name: kube-root-ca.crt
          key: ca.crt
      auth:
        serviceAccount:
          name: external-secrets-sa

---
# 7. ExternalSecret - Defines which secrets to sync and how
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: app-database-secret
  namespace: external-secrets-demo
  labels:
    app: demo-app
spec:
  # How often to refresh the secret from external store
  refreshInterval: 30s
  
  # Reference to the SecretStore
  secretStoreRef:
    name: demo-secret-store
    kind: SecretStore
  
  # Target Kubernetes Secret to create
  target:
    name: app-database-credentials
    creationPolicy: Owner  # External Secret owns the target secret
    type: Opaque
    
  # Data to extract from external store
  data:
  - secretKey: password      # Key in Kubernetes Secret
    remoteRef:
      key: mock-secret-store # ConfigMap name (simulating external store)
      property: database-password # Key in ConfigMap
  - secretKey: database-url
    remoteRef:
      key: mock-secret-store
      property: database-url

---
# 8. ExternalSecret for API keys
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: app-api-keys
  namespace: external-secrets-demo
  labels:
    app: demo-app
spec:
  refreshInterval: 1m
  secretStoreRef:
    name: demo-secret-store
    kind: SecretStore
  target:
    name: api-credentials
    creationPolicy: Owner
    # Template to transform the secret data
    template:
      type: Opaque
      data:
        # Use template to create composite values
        config.yaml: |
          api:
            key: "{{ .apikey }}"
            secret: "{{ .oauthsecret }}"
            database:
              url: "{{ .dburl }}"
  data:
  - secretKey: apikey
    remoteRef:
      key: mock-secret-store
      property: api-key
  - secretKey: oauthsecret
    remoteRef:
      key: mock-secret-store
      property: oauth-client-secret
  - secretKey: dburl
    remoteRef:
      key: mock-secret-store
      property: database-url

---
# 9. Application Pod using the external secrets
apiVersion: v1
kind: Pod
metadata:
  name: demo-app
  namespace: external-secrets-demo
  labels:
    app: demo-app
spec:
  containers:
  - name: app
    image: busybox:1.36
    command: ["sleep", "3600"]
    env:
    # Use database credentials from external secret
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: app-database-credentials
          key: password
    - name: DATABASE_URL
      valueFrom:
        secretKeyRef:
          name: app-database-credentials
          key: database-url
    # Mount API config file
    volumeMounts:
    - name: api-config
      mountPath: /etc/api
      readOnly: true
  volumes:
  - name: api-config
    secret:
      secretName: api-credentials

---
# 10. Service to demonstrate the application
apiVersion: v1
kind: Service
metadata:
  name: demo-app-service
  namespace: external-secrets-demo
spec:
  selector:
    app: demo-app
  ports:
  - port: 8080
    targetPort: 8080

# HOW THIS WORKS:
#
# 1. SecretStore defines connection to external secret management system
#    (In this demo: Kubernetes ConfigMap, but normally AWS/Vault/CyberArk)
#
# 2. ExternalSecret specifies:
#    - Which secrets to fetch from external store
#    - How to transform them  
#    - Where to store them in Kubernetes
#
# 3. External Secrets Operator:
#    - Watches ExternalSecret resources
#    - Connects to external store using SecretStore config
#    - Fetches secrets and creates/updates Kubernetes Secrets
#    - Refreshes secrets on specified interval
#
# 4. Applications consume secrets normally:
#    - Environment variables from secretKeyRef
#    - Volume mounts from secret volumes
#    - No knowledge of external secret system

# COMPARISON: Native vs External Secrets
#
# Native Kubernetes Secrets:
# ✗ Stored unencrypted in etcd
# ✗ No centralized management
# ✗ Manual rotation required
# ✗ No audit trail
# ✗ Limited access controls
#
# External Secrets:
# ✓ Encrypted at rest in dedicated secret stores
# ✓ Centralized management across environments
# ✓ Automatic rotation and refresh
# ✓ Full audit trails and access controls
# ✓ Enterprise compliance features

# PREREQUISITES FOR RUNNING THIS DEMO:
# 1. Install External Secrets Operator:
#    helm repo add external-secrets https://charts.external-secrets.io
#    helm install external-secrets external-secrets/external-secrets -n external-secrets-system --create-namespace
#
# 2. Wait for operator to be ready:
#    kubectl wait --for=condition=available --timeout=300s deployment/external-secrets -n external-secrets-system

# TESTING COMMANDS:
#
# 1. Install External Secrets Operator (if not already installed):
# helm repo add external-secrets https://charts.external-secrets.io
# helm install external-secrets external-secrets/external-secrets -n external-secrets-system --create-namespace
#
# 2. Deploy the demo:
# kubectl apply -f SIMPLE-EXTERNALSECRETS.yaml
#
# 3. Check ExternalSecret status:
# kubectl get externalsecret -n external-secrets-demo
# kubectl describe externalsecret app-database-secret -n external-secrets-demo
# kubectl describe externalsecret app-api-keys -n external-secrets-demo
#
# 4. Verify secrets were created:
# kubectl get secrets -n external-secrets-demo
# kubectl describe secret app-database-credentials -n external-secrets-demo
# kubectl describe secret api-credentials -n external-secrets-demo
#
# 5. Check secret values (base64 decoded):
# kubectl get secret app-database-credentials -n external-secrets-demo -o jsonpath='{.data.password}' | base64 -d
# kubectl get secret app-database-credentials -n external-secrets-demo -o jsonpath='{.data.database-url}' | base64 -d
#
# 6. View the generated config file:
# kubectl get secret api-credentials -n external-secrets-demo -o jsonpath='{.data.config\.yaml}' | base64 -d
#
# 7. Test that the app can access secrets:
# kubectl exec -it demo-app -n external-secrets-demo -- env | grep DB_
# kubectl exec -it demo-app -n external-secrets-demo -- cat /etc/api/config.yaml
#
# 8. Test secret refresh (modify the mock store):
# kubectl patch configmap mock-secret-store -n external-secrets-demo -p '{"data":{"database-password":"new-updated-password-456"}}'
# # Wait 30 seconds (refreshInterval) and check:
# kubectl get secret app-database-credentials -n external-secrets-demo -o jsonpath='{.data.password}' | base64 -d
#
# 9. Check External Secrets Operator logs:
# kubectl logs -n external-secrets-system -l app.kubernetes.io/name=external-secrets
#
# 10. Clean up:
# kubectl delete namespace external-secrets-demo
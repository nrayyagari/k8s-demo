# Production Secrets Management
# Enterprise-grade secret management with security, compliance, and operational excellence

---
# Production namespace with comprehensive security
apiVersion: v1
kind: Namespace
metadata:
  name: production-secrets
  labels:
    environment: production
    compliance: soc2-pci-dss-hipaa
    security-level: maximum
    data-classification: confidential
    secrets-management: enterprise
  annotations:
    security.compliance/last-audit: "2024-01-15"
    security.compliance/next-audit: "2024-04-15"
    secrets.policy/rotation-required: "true"
    secrets.policy/max-age-days: "90"

---
# Service accounts with specific roles and minimal permissions
apiVersion: v1
kind: ServiceAccount
metadata:
  name: database-secrets-sa
  namespace: production-secrets
  labels:
    component: database-access
    security-clearance: high
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/ProductionDatabaseSecretsRole

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: api-secrets-sa
  namespace: production-secrets
  labels:
    component: api-access
    security-clearance: medium
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/ProductionAPISecretsRole

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: certificate-secrets-sa
  namespace: production-secrets
  labels:
    component: certificate-management
    security-clearance: high
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/ProductionCertificateSecretsRole

---
# ClusterSecretStore for high-security database credentials (AWS Secrets Manager)
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  name: prod-database-secrets
  labels:
    environment: production
    provider: aws-secrets-manager
    security-level: high
    component: database
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-west-2
      auth:
        jwt:
          serviceAccountRef:
            name: database-secrets-sa
            namespace: production-secrets

---
# ClusterSecretStore for application secrets (HashiCorp Vault)
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  name: prod-vault-secrets
  labels:
    environment: production
    provider: hashicorp-vault
    security-level: high
    component: application
spec:
  provider:
    vault:
      server: "https://vault.production.company.com:8200"
      path: "secret"
      version: "v2"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "production-secrets"
          serviceAccountRef:
            name: api-secrets-sa
            namespace: production-secrets

---
# ClusterSecretStore for certificate management (CyberArk)
apiVersion: external-secrets.io/v1beta1
kind: ClusterSecretStore
metadata:
  name: prod-cyberark-certificates
  labels:
    environment: production
    provider: cyberark
    security-level: maximum
    component: certificates
spec:
  provider:
    cyberark:
      url: "https://cyberark.production.company.com"
      auth:
        credential:
          secretRef:
            username:
              name: cyberark-service-credentials
              key: username
            password:
              name: cyberark-service-credentials
              key: password

---
# CyberArk service credentials (managed separately with strict access)
apiVersion: v1
kind: Secret
metadata:
  name: cyberark-service-credentials
  namespace: production-secrets
  labels:
    component: cyberark-auth
    security-level: maximum
type: Opaque
stringData:
  username: "k8s-prod-secrets-service"
  password: "highly-secure-cyberark-password-2024"

---
# ExternalSecret 1: Primary database credentials with rotation
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: primary-database-credentials
  namespace: production-secrets
  labels:
    database-tier: primary
    data-classification: confidential
    rotation-schedule: daily
  annotations:
    secrets.management/owner: "database-team@company.com"
    secrets.management/emergency-contact: "oncall-database@company.com"
    compliance.audit/required: "true"
spec:
  # Short refresh for database credentials due to rotation
  refreshInterval: 30m
  secretStoreRef:
    name: prod-database-secrets
    kind: ClusterSecretStore
  target:
    name: primary-db-credentials
    creationPolicy: Owner
    template:
      type: Opaque
      metadata:
        labels:
          database-type: postgresql
          environment: production
          security-level: high
        annotations:
          secrets.rotation/last-rotated: "{{ now | date \"2006-01-02T15:04:05Z07:00\" }}"
      data:
        # Primary application database
        DATABASE_URL: "postgresql://{{ .username }}:{{ .password }}@{{ .host }}:{{ .port }}/{{ .database }}?sslmode=require&application_name=kubernetes-prod"
        # Separate connection components for specific use cases
        PGHOST: "{{ .host }}"
        PGPORT: "{{ .port }}"
        PGDATABASE: "{{ .database }}"
        PGUSER: "{{ .username }}"
        PGPASSWORD: "{{ .password }}"
        PGSSLMODE: "require"
        # Connection pool configuration
        DATABASE_POOL_CONFIG: |
          max_connections: 20
          idle_timeout: 300s
          max_lifetime: 1800s
          health_check_period: 60s
  data:
  - secretKey: username
    remoteRef:
      key: "prod/database/primary/myapp"
      property: username
  - secretKey: password
    remoteRef:
      key: "prod/database/primary/myapp"
      property: password
  - secretKey: host
    remoteRef:
      key: "prod/database/primary/myapp"
      property: host
  - secretKey: port
    remoteRef:
      key: "prod/database/primary/myapp"
      property: port
  - secretKey: database
    remoteRef:
      key: "prod/database/primary/myapp"
      property: database

---
# ExternalSecret 2: Read replica database credentials
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: replica-database-credentials
  namespace: production-secrets
  labels:
    database-tier: replica
    access-type: readonly
    performance-tier: analytics
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: prod-database-secrets
    kind: ClusterSecretStore
  target:
    name: replica-db-credentials
    creationPolicy: Owner
    template:
      type: Opaque
      data:
        # Read-only replica for analytics and reporting
        REPLICA_DATABASE_URL: "postgresql://{{ .username }}:{{ .password }}@{{ .host }}:{{ .port }}/{{ .database }}?sslmode=require&default_transaction_isolation=repeatable_read&application_name=kubernetes-replica"
        REPLICA_PGHOST: "{{ .host }}"
        REPLICA_PGUSER: "{{ .username }}"
        REPLICA_PGPASSWORD: "{{ .password }}"
  data:
  - secretKey: username
    remoteRef:
      key: "prod/database/replica/myapp"
      property: username
  - secretKey: password
    remoteRef:
      key: "prod/database/replica/myapp"
      property: password
  - secretKey: host
    remoteRef:
      key: "prod/database/replica/myapp"
      property: host
  - secretKey: port
    remoteRef:
      key: "prod/database/replica/myapp"
      property: port
  - secretKey: database
    remoteRef:
      key: "prod/database/replica/myapp"
      property: database

---
# ExternalSecret 3: Payment processing secrets (PCI compliance)
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: payment-processing-secrets
  namespace: production-secrets
  labels:
    component: payment-processing
    compliance: pci-dss
    data-classification: restricted
    security-level: maximum
  annotations:
    compliance.pci/scope: "true"
    security.audit/frequency: "monthly"
spec:
  refreshInterval: 15m  # Frequent rotation for payment processing
  secretStoreRef:
    name: prod-vault-secrets
    kind: ClusterSecretStore
  target:
    name: payment-secrets
    creationPolicy: Owner
    template:
      type: Opaque
      metadata:
        labels:
          compliance: pci-dss
          security-level: maximum
      data:
        # Stripe configuration
        stripe-config.json: |
          {
            "publishable_key": "{{ .stripe_publishable_key }}",
            "secret_key": "{{ .stripe_secret_key }}",
            "webhook_secret": "{{ .stripe_webhook_secret }}",
            "api_version": "2023-10-16",
            "connect_client_id": "{{ .stripe_connect_client_id }}"
          }
        # PayPal configuration
        paypal-config.json: |
          {
            "client_id": "{{ .paypal_client_id }}",
            "client_secret": "{{ .paypal_client_secret }}",
            "environment": "live",
            "webhook_id": "{{ .paypal_webhook_id }}"
          }
  data:
  - secretKey: stripe_publishable_key
    remoteRef:
      key: "payments/stripe/production"
      property: publishable_key
  - secretKey: stripe_secret_key
    remoteRef:
      key: "payments/stripe/production"
      property: secret_key
  - secretKey: stripe_webhook_secret
    remoteRef:
      key: "payments/stripe/production"
      property: webhook_secret
  - secretKey: stripe_connect_client_id
    remoteRef:
      key: "payments/stripe/production"
      property: connect_client_id
  - secretKey: paypal_client_id
    remoteRef:
      key: "payments/paypal/production"
      property: client_id
  - secretKey: paypal_client_secret
    remoteRef:
      key: "payments/paypal/production"
      property: client_secret
  - secretKey: paypal_webhook_id
    remoteRef:
      key: "payments/paypal/production"
      property: webhook_id

---
# ExternalSecret 4: External service integrations
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: external-service-secrets
  namespace: production-secrets
  labels:
    component: external-integrations
    security-level: medium
spec:
  refreshInterval: 2h
  secretStoreRef:
    name: prod-vault-secrets
    kind: ClusterSecretStore
  target:
    name: external-services
    creationPolicy: Owner
    template:
      type: Opaque
      data:
        # Email service configuration
        email-config.yaml: |
          sendgrid:
            api_key: "{{ .sendgrid_api_key }}"
            sender_email: "noreply@company.com"
            sender_name: "Company Name"
          ses:
            access_key_id: "{{ .ses_access_key }}"
            secret_access_key: "{{ .ses_secret_key }}"
            region: "us-west-2"
        # Monitoring and analytics
        monitoring-config.yaml: |
          datadog:
            api_key: "{{ .datadog_api_key }}"
            app_key: "{{ .datadog_app_key }}"
          newrelic:
            license_key: "{{ .newrelic_license_key }}"
          mixpanel:
            token: "{{ .mixpanel_token }}"
        # Cloud services
        cloud-config.yaml: |
          aws:
            access_key_id: "{{ .aws_access_key }}"
            secret_access_key: "{{ .aws_secret_key }}"
          gcp:
            service_account_key: "{{ .gcp_service_account_key }}"
  data:
  - secretKey: sendgrid_api_key
    remoteRef:
      key: "integrations/sendgrid/production"
      property: api_key
  - secretKey: ses_access_key
    remoteRef:
      key: "integrations/aws-ses/production"
      property: access_key_id
  - secretKey: ses_secret_key
    remoteRef:
      key: "integrations/aws-ses/production"
      property: secret_access_key
  - secretKey: datadog_api_key
    remoteRef:
      key: "monitoring/datadog/production"
      property: api_key
  - secretKey: datadog_app_key
    remoteRef:
      key: "monitoring/datadog/production"
      property: app_key
  - secretKey: newrelic_license_key
    remoteRef:
      key: "monitoring/newrelic/production"
      property: license_key
  - secretKey: mixpanel_token
    remoteRef:
      key: "analytics/mixpanel/production"
      property: token
  - secretKey: aws_access_key
    remoteRef:
      key: "cloud/aws/production"
      property: access_key_id
  - secretKey: aws_secret_key
    remoteRef:
      key: "cloud/aws/production"
      property: secret_access_key
  - secretKey: gcp_service_account_key
    remoteRef:
      key: "cloud/gcp/production"
      property: service_account_key

---
# ExternalSecret 5: SSL/TLS certificates from CyberArk
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: ssl-certificates
  namespace: production-secrets
  labels:
    component: ssl-certificates
    certificate-authority: internal-ca
    security-level: high
spec:
  refreshInterval: 6h  # Certificates need frequent checks for expiration
  secretStoreRef:
    name: prod-cyberark-certificates
    kind: ClusterSecretStore
  target:
    name: production-tls-certs
    creationPolicy: Owner
    type: kubernetes.io/tls
    template:
      metadata:
        annotations:
          cert-manager.io/managed: "false"
          certificates.security/issuer: "company-internal-ca"
          certificates.security/expiry-monitoring: "enabled"
  data:
  - secretKey: tls.crt
    remoteRef:
      key: "SSL-Certificates-Production"
      property: "app.company.com-Certificate"
  - secretKey: tls.key
    remoteRef:
      key: "SSL-Certificates-Production"  
      property: "app.company.com-PrivateKey"

---
# Production application with comprehensive secret management
apiVersion: apps/v1
kind: Deployment
metadata:
  name: production-application
  namespace: production-secrets
  labels:
    app: production-app
    tier: application
    environment: production
    security-level: high
  annotations:
    deployment.security/secrets-last-rotated: "2024-01-15T10:30:00Z"
    deployment.compliance/audit-required: "true"
spec:
  replicas: 10
  selector:
    matchLabels:
      app: production-app
  template:
    metadata:
      labels:
        app: production-app
        version: v2.1.0
      annotations:
        secrets.injection/enabled: "true"
        security.monitoring/enabled: "true"
    spec:
      serviceAccountName: api-secrets-sa
      securityContext:
        runAsNonRoot: true
        runAsUser: 10001
        runAsGroup: 10001
        fsGroup: 10001
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: app
        image: myapp:v2.1.0-production
        ports:
        - containerPort: 8080
          name: http
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
          seccompProfile:
            type: RuntimeDefault
        env:
        # Database connections
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: primary-db-credentials
              key: DATABASE_URL
        - name: REPLICA_DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: replica-db-credentials
              key: REPLICA_DATABASE_URL
        # Application configuration
        - name: NODE_ENV
          value: "production"
        - name: LOG_LEVEL
          value: "info"
        - name: METRICS_ENABLED
          value: "true"
        volumeMounts:
        # Payment processing configuration (PCI compliance)
        - name: payment-config
          mountPath: /app/config/payments
          readOnly: true
        # External service configurations
        - name: external-services-config
          mountPath: /app/config/services
          readOnly: true
        # SSL certificates
        - name: tls-certs
          mountPath: /app/certs
          readOnly: true
        # Temporary and cache directories
        - name: tmp
          mountPath: /tmp
        - name: app-cache
          mountPath: /app/cache
        - name: logs
          mountPath: /app/logs
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        # Comprehensive health checks
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        startupProbe:
          httpGet:
            path: /health/startup
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 30
      volumes:
      - name: payment-config
        secret:
          secretName: payment-secrets
          defaultMode: 0400  # Read-only for owner only
      - name: external-services-config
        secret:
          secretName: external-services
          defaultMode: 0440  # Read-only for owner and group
      - name: tls-certs
        secret:
          secretName: production-tls-certs
          defaultMode: 0444  # Read-only for all
      - name: tmp
        emptyDir:
          sizeLimit: "1Gi"
      - name: app-cache
        emptyDir:
          sizeLimit: "2Gi"
      - name: logs
        emptyDir:
          sizeLimit: "5Gi"
      # High availability and security
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - production-app
              topologyKey: kubernetes.io/hostname
      nodeSelector:
        node-type: production
        security-zone: high

---
# Production service with comprehensive configuration
apiVersion: v1
kind: Service
metadata:
  name: production-app-service
  namespace: production-secrets
  labels:
    app: production-app
    environment: production
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:us-west-2:123456789012:certificate/production-cert"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"
    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"
    service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"
    service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "300"
spec:
  selector:
    app: production-app
  ports:
  - port: 443
    targetPort: 8080
    name: https
    protocol: TCP
  - port: 80
    targetPort: 8080
    name: http
    protocol: TCP
  type: LoadBalancer

---
# Database maintenance job with privileged access
apiVersion: batch/v1
kind: CronJob
metadata:
  name: database-maintenance
  namespace: production-secrets
  labels:
    component: database-maintenance
    security-level: high
    access-type: privileged
spec:
  schedule: "0 3 * * 0"  # Weekly at 3 AM Sunday
  concurrencyPolicy: Forbid
  failedJobsHistoryLimit: 3
  successfulJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            job-type: database-maintenance
          annotations:
            security.privileged/database-admin: "true"
        spec:
          restartPolicy: OnFailure
          serviceAccountName: database-secrets-sa
          securityContext:
            runAsNonRoot: true
            runAsUser: 10002
            fsGroup: 10002
          containers:
          - name: db-maintenance
            image: postgres:16-alpine
            command:
            - /bin/bash
            - -c
            - |
              echo "Starting weekly database maintenance..."
              echo "Connected to: $PGHOST:$PGPORT/$PGDATABASE as $PGUSER"
              
              # Run maintenance tasks
              psql -c "VACUUM ANALYZE;"
              psql -c "REINDEX DATABASE $PGDATABASE;"
              psql -c "SELECT pg_stat_reset();"
              
              echo "Database maintenance completed successfully"
            env:
            - name: PGHOST
              valueFrom:
                secretKeyRef:
                  name: primary-db-credentials
                  key: PGHOST
            - name: PGPORT
              valueFrom:
                secretKeyRef:
                  name: primary-db-credentials
                  key: PGPORT
            - name: PGDATABASE
              valueFrom:
                secretKeyRef:
                  name: primary-db-credentials
                  key: PGDATABASE
            - name: PGUSER
              valueFrom:
                secretKeyRef:
                  name: primary-db-credentials
                  key: PGUSER
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: primary-db-credentials
                  key: PGPASSWORD
            - name: PGSSLMODE
              valueFrom:
                secretKeyRef:
                  name: primary-db-credentials
                  key: PGSSLMODE
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "256Mi"
                cpu: "200m"
            volumeMounts:
            - name: tmp
              mountPath: /tmp
          volumes:
          - name: tmp
            emptyDir: {}

# PRODUCTION SECRETS MANAGEMENT FEATURES:
#
# ✓ Multi-provider secret stores (AWS, Vault, CyberArk)
# ✓ Role-based service accounts with minimal permissions
# ✓ Frequent secret rotation (15m - 6h intervals)
# ✓ Compliance annotations and labeling
# ✓ Security context hardening
# ✓ Comprehensive health checks
# ✓ High availability deployment
# ✓ Audit logging and monitoring
# ✓ PCI DSS compliance for payment processing
# ✓ Encrypted secrets at rest
# ✓ Network security with TLS
# ✓ Privileged access management
# ✓ Emergency access procedures
# ✓ Resource limits and quotas
# ✓ Anti-affinity rules for resilience

# TESTING COMMANDS:
#
# 1. Deploy production secrets management:
# kubectl apply -f 06-production-secrets.yaml
#
# 2. Verify all ExternalSecrets are synced:
# kubectl get externalsecret -n production-secrets
# kubectl describe externalsecret primary-database-credentials -n production-secrets
#
# 3. Check secret creation and metadata:
# kubectl get secrets -n production-secrets
# kubectl describe secret primary-db-credentials -n production-secrets
# kubectl describe secret payment-secrets -n production-secrets
#
# 4. Verify application deployment:
# kubectl get deployment production-application -n production-secrets
# kubectl get pods -l app=production-app -n production-secrets
#
# 5. Check service account permissions:
# kubectl describe sa database-secrets-sa -n production-secrets
# kubectl describe sa api-secrets-sa -n production-secrets
#
# 6. Test database connectivity:
# kubectl exec -it $(kubectl get pod -l app=production-app -n production-secrets -o jsonpath='{.items[0].metadata.name}') -n production-secrets -- env | grep DATABASE_URL
#
# 7. Verify payment processing configuration:
# kubectl exec -it $(kubectl get pod -l app=production-app -n production-secrets -o jsonpath='{.items[0].metadata.name}') -n production-secrets -- cat /app/config/payments/stripe-config.json
#
# 8. Check SSL certificate configuration:
# kubectl exec -it $(kubectl get pod -l app=production-app -n production-secrets -o jsonpath='{.items[0].metadata.name}') -n production-secrets -- ls -la /app/certs/
#
# 9. Monitor CronJob execution:
# kubectl get cronjob database-maintenance -n production-secrets
# kubectl get jobs -n production-secrets
#
# 10. Test secret rotation:
# # Trigger manual refresh by adding annotation
# kubectl annotate externalsecret primary-database-credentials -n production-secrets force-sync=$(date +%s) --overwrite
# # Check if secret was updated
# kubectl get secret primary-db-credentials -n production-secrets -o yaml | grep -A5 metadata.annotations
#
# 11. Verify security hardening:
# kubectl exec -it $(kubectl get pod -l app=production-app -n production-secrets -o jsonpath='{.items[0].metadata.name}') -n production-secrets -- id
# kubectl exec -it $(kubectl get pod -l app=production-app -n production-secrets -o jsonpath='{.items[0].metadata.name}') -n production-secrets -- capsh --print
#
# 12. Check service exposure:
# kubectl get svc production-app-service -n production-secrets
#
# 13. Monitor External Secrets Operator logs:
# kubectl logs -n external-secrets-system -l app.kubernetes.io/name=external-secrets | grep production-secrets
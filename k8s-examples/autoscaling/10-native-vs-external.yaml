# Native vs External: HPA and VPA Components
# WHY: Understanding what's built-in vs what needs installation
# WHAT: Clear breakdown of requirements for each autoscaler

# =================== HPA (HORIZONTAL POD AUTOSCALER) ===================

# NATIVE TO KUBERNETES:
# ✅ HPA Controller - Built into kube-controller-manager
# ✅ HPA API - Part of autoscaling/v2 API group
# ✅ HPA CRD - Standard Kubernetes resource

# EXTERNAL REQUIREMENTS:
# ❌ metrics-server - Must be installed separately
# ❌ Custom metrics API - Optional, for advanced metrics
# ❌ External metrics API - Optional, for external sources

# WHY metrics-server is needed:
# - HPA controller needs current resource usage data
# - Kubelet collects metrics but doesn't expose them via API
# - metrics-server aggregates kubelet data and exposes /apis/metrics.k8s.io/v1beta1

# Installation status in different environments:
# - Managed clusters (EKS, GKE, AKS): metrics-server pre-installed
# - Minikube: Enable with `minikube addons enable metrics-server`
# - Kind: Must install manually
# - Bare metal: Must install manually

---
# =================== VPA (VERTICAL POD AUTOSCALER) ===================

# NATIVE TO KUBERNETES:
# ❌ Nothing - VPA is entirely external

# EXTERNAL REQUIREMENTS:
# ❌ VPA Recommender - Analyzes usage patterns
# ❌ VPA Updater - Modifies pod resource requests
# ❌ VPA Admission Controller - Applies recommendations to new pods
# ❌ VPA CRDs - Custom resource definitions

# VPA Components breakdown:
apiVersion: v1
kind: Namespace
metadata:
  name: vpa-system
  labels:
    component: vpa

---
# VPA Recommender - The brain of VPA
# Analyzes historical resource usage and provides recommendations
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vpa-recommender
  namespace: vpa-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vpa-recommender
  template:
    metadata:
      labels:
        app: vpa-recommender
    spec:
      containers:
      - name: recommender
        image: k8s.gcr.io/autoscaling/vpa-recommender:0.13.0
        command:
        - ./recommender
        - --v=4
        - --stderrthreshold=info
        - --pod-recommendation-min-cpu-millicores=25
        - --pod-recommendation-min-memory-mb=100
        resources:
          requests:
            cpu: 100m
            memory: 500Mi
          limits:
            cpu: 1000m
            memory: 1000Mi

---
# VPA Updater - Applies recommendations by restarting pods
# Only works in "Auto" or "Recreation" mode
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vpa-updater
  namespace: vpa-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vpa-updater
  template:
    metadata:
      labels:
        app: vpa-updater
    spec:
      containers:
      - name: updater
        image: k8s.gcr.io/autoscaling/vpa-updater:0.13.0
        command:
        - ./updater
        - --v=4
        - --stderrthreshold=info
        - --min-replicas=2
        resources:
          requests:
            cpu: 100m
            memory: 500Mi
          limits:
            cpu: 1000m
            memory: 1000Mi

---
# VPA Admission Controller - Applies recommendations to new pods
# Works in "Initial" mode for new pods only
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vpa-admission-controller
  namespace: vpa-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vpa-admission-controller
  template:
    metadata:
      labels:
        app: vpa-admission-controller
    spec:
      containers:
      - name: admission-controller
        image: k8s.gcr.io/autoscaling/vpa-admission-controller:0.13.0
        command:
        - ./admission-controller
        - --v=4
        - --stderrthreshold=info
        - --client-ca-file=/etc/tls-certs/ca.crt
        - --tls-cert-file=/etc/tls-certs/tls.crt
        - --tls-private-key-file=/etc/tls-certs/tls.key
        ports:
        - containerPort: 8000
        resources:
          requests:
            cpu: 50m
            memory: 200Mi
          limits:
            cpu: 200m
            memory: 1000Mi

---
# =================== SIMPLE AUTOSCALING RECOMMENDATIONS ===================

# FOR SIMPLE AUTOSCALING, START WITH HPA ONLY:
# 
# Why HPA first:
# ✅ Easier to install (just metrics-server)
# ✅ Less complex (no pod restarts)
# ✅ Handles most common scaling scenarios
# ✅ Works well for stateless applications
# ✅ Fast reaction to load changes
# 
# Simple HPA installation:
# 1. Install metrics-server:
#    kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
# 
# 2. Create HPA:
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: simple-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70

---
# =================== WHEN TO ADD VPA ===================

# Add VPA later when you need:
# ✅ Resource optimization (cost savings)
# ✅ Right-sizing for unknown workloads
# ✅ Handling resource-intensive applications
# ✅ Complementing HPA for complete autoscaling

# VPA installation is more complex:
# 1. Install VPA components (3 deployments + CRDs)
# 2. Configure RBAC permissions
# 3. Set up admission webhooks
# 4. Choose update mode carefully

---
# =================== PRACTICAL DECISION TREE ===================

# SCENARIO 1: Web application with variable traffic
# SOLUTION: HPA only
# WHY: Handles traffic spikes by scaling out
# COMPLEXITY: Low

# SCENARIO 2: Unknown resource requirements
# SOLUTION: VPA in "Off" mode first, then HPA
# WHY: VPA provides sizing recommendations
# COMPLEXITY: Medium

# SCENARIO 3: Complete autoscaling solution
# SOLUTION: VPA (Initial mode) + HPA
# WHY: VPA optimizes pod size, HPA handles load
# COMPLEXITY: High

# SCENARIO 4: Cost optimization focus
# SOLUTION: VPA in "Auto" mode
# WHY: Continuously optimizes resource usage
# COMPLEXITY: High (pod restarts)

---
# =================== INSTALLATION VERIFICATION ===================

# Check HPA prerequisites:
# kubectl get pods -n kube-system | grep metrics-server
# kubectl get --raw /apis/metrics.k8s.io/v1beta1/nodes

# Check VPA prerequisites:
# kubectl get pods -n vpa-system
# kubectl get crd | grep verticalpodautoscaler

# Test HPA:
# kubectl create deployment test-app --image=nginx
# kubectl expose deployment test-app --port=80
# kubectl autoscale deployment test-app --cpu-percent=50 --min=1 --max=10
# kubectl get hpa

# Test VPA:
# kubectl apply -f vpa-test.yaml
# kubectl get vpa
# kubectl describe vpa <vpa-name>

---
# =================== SUMMARY ===================

# NATIVE TO KUBERNETES:
# - HPA controller and API
# - Standard resource monitoring (kubelet)
# - Basic autoscaling concepts

# EXTERNAL REQUIREMENTS:
# - metrics-server (for HPA)
# - VPA components (for VPA)
# - Custom/external metrics APIs (for advanced HPA)

# FOR SIMPLE AUTOSCALING:
# 1. Start with HPA + metrics-server
# 2. Add VPA later for optimization
# 3. Use managed clusters when possible (pre-installed components)

# COMPLEXITY LEVELS:
# Basic: HPA with CPU scaling
# Intermediate: HPA with multiple metrics
# Advanced: HPA + VPA together
# Expert: Custom metrics and external metrics
# Understanding HPA and VPA Metrics - The Real Story
# WHY: Most people misunderstand what "CPU utilization" actually means
# WHAT: It's a ratio based on resource REQUESTS, not actual hardware usage

apiVersion: apps/v1
kind: Deployment
metadata:
  name: metrics-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: metrics-demo
  template:
    metadata:
      labels:
        app: metrics-demo
    spec:
      containers:
      - name: metrics-demo
        image: nginx:1.21
        resources:
          requests:
            cpu: 100m        # This is the KEY number for HPA calculations
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        ports:
        - containerPort: 80

---
# HPA Configuration
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: metrics-demo-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: metrics-demo
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70    # This means 70% of the REQUEST (not actual CPU)

---
# =================== HPA METRIC CALCULATION ===================
# 
# Example Scenario:
# - Pod CPU Request: 100m (0.1 CPU cores)
# - Pod CPU Limit: 500m (0.5 CPU cores)
# - Actual CPU Usage: 70m (0.07 CPU cores)
# 
# HPA CPU Utilization = (70m / 100m) × 100 = 70%
# 
# This means:
# ✅ HPA sees 70% utilization (70m out of 100m requested)
# ❌ NOT 14% utilization (70m out of 500m limit)
# ❌ NOT 7% utilization (70m out of 1000m node capacity)
# 
# =================== WHY THIS MATTERS ===================
# 
# Scenario 1: Low CPU Request
# requests:
#   cpu: 50m          # Very low request
# 
# If actual usage is 60m:
# HPA sees: (60m / 50m) × 100 = 120% utilization
# Result: HPA will scale UP immediately!
# 
# Scenario 2: High CPU Request  
# requests:
#   cpu: 200m         # High request
# 
# If actual usage is 60m:
# HPA sees: (60m / 200m) × 100 = 30% utilization
# Result: HPA will scale DOWN (if current > target)
# 
# =================== MEMORY WORKS THE SAME WAY ===================
# 
# Memory Utilization = (Current Memory Usage / Memory Request) × 100
# 
# Example:
# - Memory Request: 128Mi
# - Actual Memory Usage: 90Mi
# - HPA Memory Utilization: (90Mi / 128Mi) × 100 = 70%

---
# =================== VPA METRICS ARE DIFFERENT ===================
# 
# VPA doesn't use "utilization" - it uses ACTUAL resource consumption
# 
# VPA tracks:
# - Actual CPU usage over time (in millicores)
# - Actual memory usage over time (in bytes)
# - Peak usage, average usage, and usage patterns
# 
# VPA Algorithm:
# 1. Collects actual usage data for several minutes/hours
# 2. Calculates recommended requests based on:
#    - 90th percentile of CPU usage
#    - 95th percentile of memory usage
#    - Historical patterns and trends
# 3. Provides recommendations independent of current requests
# 
# Example VPA calculation:
# - Observed CPU usage: 45m, 60m, 80m, 55m, 70m (over time)
# - VPA recommendation: ~75m (based on 90th percentile + buffer)
# - Current request: 100m
# - VPA suggests: Reduce CPU request to 75m

---
# =================== PRACTICAL IMPLICATIONS ===================
# 
# 1. HPA is RELATIVE to your resource requests
#    - Set requests too low → HPA scales up too aggressively
#    - Set requests too high → HPA won't scale when needed
# 
# 2. VPA is ABSOLUTE based on actual usage
#    - Ignores your current requests
#    - Recommends based on observed reality
# 
# 3. This is why HPA + VPA work well together:
#    - VPA sets the RIGHT requests based on actual usage
#    - HPA scales based on those RIGHT requests
# 
# =================== MONITORING THE REAL METRICS ===================
# 
# See what HPA actually sees:
# kubectl describe hpa metrics-demo-hpa
# 
# Look for:
# Current CPU utilization: 45% (70m) of requests
#                          ↑    ↑
#                     percentage  actual usage
# 
# See what VPA actually sees:
# kubectl describe vpa metrics-demo-vpa
# 
# Look for:
# target:
#   cpu: "75m"     ← VPA's recommendation based on actual usage
#   memory: "150Mi"
# 
# See actual resource usage:
# kubectl top pods -l app=metrics-demo
# 
# Output shows:
# NAME                           CPU(cores)   MEMORY(bytes)
# metrics-demo-abc123            70m          90Mi
#                                ↑            ↑
#                          actual usage  actual usage
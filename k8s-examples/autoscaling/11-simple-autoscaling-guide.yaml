# Simple Autoscaling Guide - Start Here!
# WHY: Most people overcomplicate autoscaling
# WHAT: The minimal, practical setup that works for 90% of use cases

# =================== STEP 1: INSTALL METRICS-SERVER ===================

# For most managed clusters (EKS, GKE, AKS):
# Already installed! Skip this step.

# For minikube:
# minikube addons enable metrics-server

# For kind or bare metal:
# kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

# Verify installation:
# kubectl get pods -n kube-system | grep metrics-server
# kubectl top nodes  # Should show resource usage

---
# =================== STEP 2: SIMPLE APPLICATION ===================

# Your application MUST have resource requests defined
apiVersion: apps/v1
kind: Deployment
metadata:
  name: simple-web-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: simple-web-app
  template:
    metadata:
      labels:
        app: simple-web-app
    spec:
      containers:
      - name: web-app
        image: nginx:1.21
        resources:
          requests:
            cpu: 100m      # CRITICAL: HPA needs this
            memory: 128Mi  # CRITICAL: HPA needs this
          limits:
            cpu: 500m      # Optional but recommended
            memory: 512Mi  # Optional but recommended
        ports:
        - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: simple-web-service
spec:
  selector:
    app: simple-web-app
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP

---
# =================== STEP 3: SIMPLE HPA ===================

# Start with CPU-only autoscaling
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: simple-web-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: simple-web-app
  minReplicas: 2          # Never go below 2 for availability
  maxReplicas: 10         # Reasonable upper limit
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70    # Scale when CPU > 70% of request

---
# =================== STEP 4: DEPLOY AND TEST ===================

# Deploy everything:
# kubectl apply -f simple-autoscaling-guide.yaml

# Verify HPA is working:
# kubectl get hpa simple-web-hpa
# Expected output: simple-web-hpa   Deployment/simple-web-app   5%/70%   2   10   2   1m

# Generate load to test scaling:
# kubectl run load-generator --image=busybox --restart=Never -- /bin/sh -c "while true; do wget -q -O- http://simple-web-service; done"

# Watch scaling happen:
# kubectl get hpa simple-web-hpa --watch
# kubectl get pods -l app=simple-web-app --watch

# Clean up load generator:
# kubectl delete pod load-generator

---
# =================== STEP 5: MONITORING (OPTIONAL) ===================

# Basic monitoring commands:
# kubectl get hpa                          # Current HPA status
# kubectl top pods -l app=simple-web-app   # Resource usage
# kubectl describe hpa simple-web-hpa      # Detailed info and events

# What you should see during scaling:
# 1. Normal load: 2 replicas, ~20% CPU utilization
# 2. High load: CPU rises above 70%
# 3. HPA triggers: Creates more pods
# 4. Load distributes: CPU drops back to target
# 5. Stable state: More replicas, ~70% CPU each

---
# =================== WHEN TO ADD MORE COMPLEXITY ===================

# Add memory scaling when:
# - Your app is memory-intensive
# - CPU scaling alone isn't enough
# - You see memory pressure issues

# Add custom metrics when:
# - You have application-specific metrics (requests/second, queue length)
# - CPU/memory don't reflect true load
# - You need more sophisticated scaling logic

# Add VPA when:
# - You want to optimize resource costs
# - You don't know optimal resource requests
# - You want automated resource management

---
# =================== COMMON MISTAKES TO AVOID ===================

# ❌ No resource requests defined
# resources: {}  # HPA won't work!

# ❌ Requests too low
# requests:
#   cpu: 10m     # Will trigger scaling too early

# ❌ Requests too high  
# requests:
#   cpu: 1000m   # Will never scale up

# ❌ minReplicas: 1
# minReplicas: 1  # No high availability

# ❌ Target utilization too low
# averageUtilization: 30  # Will scale up too aggressively

# ❌ Target utilization too high
# averageUtilization: 90  # Will scale up too late

---
# =================== PRODUCTION CONSIDERATIONS ===================

# 1. Set reasonable resource requests:
#    - Start with educated guesses
#    - Monitor actual usage
#    - Adjust based on observation

# 2. Set appropriate scaling targets:
#    - CPU: 60-80% is usually good
#    - Memory: 70-90% is usually good
#    - Lower = more responsive but more expensive
#    - Higher = more resource efficient but less responsive

# 3. Configure scaling behavior (optional):
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: production-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: simple-web-app
  minReplicas: 2
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  behavior:                    # Optional: Control scaling speed
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100           # Can double pods at once
        periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300  # Wait 5 minutes before scaling down
      policies:
      - type: Percent
        value: 10            # Scale down max 10% at once
        periodSeconds: 60

---
# =================== TROUBLESHOOTING ===================

# HPA shows "unknown" for metrics:
# - Check: kubectl get pods -n kube-system | grep metrics-server
# - Check: kubectl top nodes
# - Solution: Install/fix metrics-server

# HPA doesn't scale:
# - Check: kubectl describe hpa <name>
# - Look for: Events section for errors
# - Common issue: Missing resource requests

# Scaling too aggressive:
# - Lower target utilization
# - Increase stabilization windows
# - Check if requests are too low

# Scaling too slow:
# - Increase target utilization
# - Decrease stabilization windows
# - Check if requests are too high

---
# =================== SUMMARY: SIMPLE AUTOSCALING ===================

# MINIMAL SETUP (90% of use cases):
# 1. Install metrics-server (if not already installed)
# 2. Add resource requests to your deployment
# 3. Create HPA with CPU target ~70%
# 4. Start with 2 min replicas, reasonable max
# 5. Monitor and adjust

# TOTAL COMPLEXITY: 
# - 1 external component (metrics-server)
# - 1 additional resource (HPA)
# - 5 minutes to set up
# - Works for most web applications

# WHEN TO EVOLVE:
# - Add memory metrics if needed
# - Add VPA for cost optimization
# - Add custom metrics for advanced scenarios
# - But start simple and evolve based on real needs!
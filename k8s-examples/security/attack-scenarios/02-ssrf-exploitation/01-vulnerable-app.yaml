# WARNING: DELIBERATELY VULNERABLE - FOR SECURITY TRAINING ONLY
# NEVER deploy this in production environments

apiVersion: v1
kind: Namespace
metadata:
  name: security-demo
  labels:
    security-training: "true"
    environment: "vulnerable"
---
# Vulnerable SSRF application (Python Flask)
apiVersion: v1
kind: ConfigMap
metadata:
  name: vulnerable-ssrf-app
  namespace: security-demo
data:
  app.py: |
    from flask import Flask, request, jsonify
    import requests
    import os
    
    app = Flask(__name__)
    
    @app.route('/')
    def home():
        return '''
        <h1>SSRF Vulnerable Application</h1>
        <p>This is a deliberately vulnerable application for security training.</p>
        <form action="/fetch" method="get">
            <label>Enter URL to fetch:</label>
            <input type="text" name="url" placeholder="http://example.com" style="width: 400px;">
            <input type="submit" value="Fetch">
        </form>
        <h3>Common Attack Targets:</h3>
        <ul>
            <li><a href="/fetch?url=http://169.254.169.254/latest/meta-data/">AWS Metadata</a></li>
            <li><a href="/fetch?url=http://kubernetes.default.svc.cluster.local/">Kubernetes API</a></li>
            <li><a href="/fetch?url=http://admin-api.production.svc.cluster.local:8080/">Internal Admin API</a></li>
        </ul>
        '''
    
    @app.route('/fetch')
    def fetch_url():
        url = request.args.get('url')
        if not url:
            return jsonify({'error': 'No URL provided'}), 400
        
        try:
            # VULNERABILITY: No validation or restrictions on URL
            response = requests.get(url, timeout=10)
            return jsonify({
                'url': url,
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'content': response.text[:1000]  # Limit content for display
            })
        except Exception as e:
            return jsonify({'error': str(e)}), 500
    
    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000, debug=True)
  
  requirements.txt: |
    Flask==2.3.3
    requests==2.31.0
    
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vulnerable-ssrf-app
  namespace: security-demo
  labels:
    app: vulnerable-ssrf
    security-demo: "true"
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vulnerable-ssrf
  template:
    metadata:
      labels:
        app: vulnerable-ssrf
        security-demo: "true"
    spec:
      containers:
      - name: app
        image: python:3.9-slim
        command: ["/bin/bash"]
        args:
        - -c
        - |
          pip install -r /app/requirements.txt
          python /app/app.py
        ports:
        - containerPort: 5000
        volumeMounts:
        - name: app-code
          mountPath: /app
        env:
        - name: FLASK_ENV
          value: "development"
        # VULNERABILITY: No security context restrictions
        # VULNERABILITY: No resource limits
        # VULNERABILITY: Running as root
      volumes:
      - name: app-code
        configMap:
          name: vulnerable-ssrf-app
      # VULNERABILITY: No automountServiceAccountToken=false
      # VULNERABILITY: Uses default service account
---
apiVersion: v1
kind: Service
metadata:
  name: vulnerable-ssrf-service
  namespace: security-demo
spec:
  selector:
    app: vulnerable-ssrf
  ports:
  - port: 80
    targetPort: 5000
    protocol: TCP
  type: ClusterIP
---
# Simulated internal admin API (target for SSRF)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: admin-api
  namespace: security-demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: admin-api
  template:
    metadata:
      labels:
        app: admin-api
    spec:
      containers:
      - name: admin
        image: nginx:alpine
        ports:
        - containerPort: 80
        env:
        - name: ADMIN_SECRET
          value: "super-secret-admin-key-12345"
        volumeMounts:
        - name: admin-content
          mountPath: /usr/share/nginx/html
      volumes:
      - name: admin-content
        configMap:
          name: admin-api-content
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: admin-api-content
  namespace: security-demo
data:
  index.html: |
    <html>
    <head><title>Internal Admin API</title></head>
    <body>
        <h1>Internal Admin API</h1>
        <p>This should only be accessible internally!</p>
        <h3>Endpoints:</h3>
        <ul>
            <li><a href="/admin/users">/admin/users</a> - User management</li>
            <li><a href="/admin/config">/admin/config</a> - System configuration</li>
            <li><a href="/health">/health</a> - Health check</li>
        </ul>
        <p><strong>Admin Secret:</strong> super-secret-admin-key-12345</p>
    </body>
    </html>
  health: |
    {"status": "healthy", "admin_token": "admin-12345", "internal": true}
---
apiVersion: v1
kind: Service
metadata:
  name: admin-api
  namespace: security-demo
spec:
  selector:
    app: admin-api
  ports:
  - port: 8080
    targetPort: 80
  type: ClusterIP
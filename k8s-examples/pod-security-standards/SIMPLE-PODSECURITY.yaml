# SIMPLE POD SECURITY: Start Here
# Basic pod security context setup to understand container security

---
# 1. Create namespace for our security demos
apiVersion: v1
kind: Namespace
metadata:
  name: security-demo
  labels:
    purpose: learning-pod-security

---
# 2. INSECURE POD: Shows what NOT to do
apiVersion: v1
kind: Pod
metadata:
  name: insecure-pod
  namespace: security-demo
  labels:
    security-level: dangerous
    purpose: demonstration
spec:
  containers:
  - name: insecure-container
    image: nginx:1.27
    ports:
    - containerPort: 80
    # NO SECURITY CONTEXT = DANGEROUS
    # - Runs as root (UID 0)
    # - Can write to root filesystem
    # - Has all capabilities
    # - Can escalate privileges

---
# 3. BASIC SECURE POD: Minimal security improvements
apiVersion: v1
kind: Pod
metadata:
  name: basic-secure-pod
  namespace: security-demo
  labels:
    security-level: basic
    purpose: demonstration
spec:
  # Pod-level security context (applies to all containers)
  securityContext:
    runAsNonRoot: true  # Prevent running as root
    runAsUser: 1000     # Run as specific user ID
    runAsGroup: 1000    # Run as specific group ID
    fsGroup: 2000       # Group ownership for volumes
  containers:
  - name: secure-container
    image: nginx:1.27
    ports:
    - containerPort: 8080  # Non-privileged port
    # Container-level security context (overrides pod-level)
    securityContext:
      allowPrivilegeEscalation: false  # Prevent privilege escalation
      capabilities:
        drop:
        - ALL  # Drop all capabilities

---
# 4. HIGHLY SECURE POD: Maximum security (Restricted profile)
apiVersion: v1
kind: Pod
metadata:
  name: restricted-secure-pod
  namespace: security-demo
  labels:
    security-level: restricted
    purpose: demonstration
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 65534    # nobody user
    runAsGroup: 65534   # nobody group
    fsGroup: 65534
    seccompProfile:
      type: RuntimeDefault  # Use default seccomp profile
  containers:
  - name: highly-secure-container
    image: nginx:1.27
    ports:
    - containerPort: 8080
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true  # Read-only root filesystem
      capabilities:
        drop:
        - ALL
      seccompProfile:
        type: RuntimeDefault
    # Mount writable directories for nginx
    volumeMounts:
    - name: tmp
      mountPath: /tmp
    - name: var-cache
      mountPath: /var/cache/nginx
    - name: var-run
      mountPath: /var/run
  volumes:
  - name: tmp
    emptyDir: {}
  - name: var-cache
    emptyDir: {}
  - name: var-run
    emptyDir: {}

---
# 5. Service to test connectivity
apiVersion: v1
kind: Service
metadata:
  name: secure-service
  namespace: security-demo
spec:
  selector:
    security-level: basic
  ports:
  - port: 8080
    targetPort: 8080

---
# 6. Test client pod with minimal security
apiVersion: v1
kind: Pod
metadata:
  name: test-client
  namespace: security-demo
  labels:
    app: test-client
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
  containers:
  - name: client
    image: busybox:1.36
    command: ["sleep", "3600"]
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL

# SECURITY COMPARISON:
#
# insecure-pod:
# ✗ Runs as root (UID 0)
# ✗ Can write to root filesystem
# ✗ Has all Linux capabilities
# ✗ Can escalate privileges
# ✗ No seccomp restrictions
#
# basic-secure-pod:
# ✓ Runs as non-root user (UID 1000)
# ✗ Can still write to root filesystem
# ✓ Drops all capabilities
# ✓ Prevents privilege escalation
# ✗ No seccomp profile
#
# restricted-secure-pod:
# ✓ Runs as nobody user (UID 65534)
# ✓ Read-only root filesystem
# ✓ Drops all capabilities  
# ✓ Prevents privilege escalation
# ✓ Uses runtime default seccomp
# ✓ Follows Pod Security Standards "Restricted" profile

# TESTING COMMANDS:
#
# 1. Deploy all pods:
# kubectl apply -f SIMPLE-PODSECURITY.yaml
#
# 2. Check which user each pod runs as:
# kubectl exec -it insecure-pod -n security-demo -- id
# kubectl exec -it basic-secure-pod -n security-demo -- id  
# kubectl exec -it restricted-secure-pod -n security-demo -- id
#
# 3. Test filesystem write permissions:
# kubectl exec -it insecure-pod -n security-demo -- touch /test-file
# kubectl exec -it basic-secure-pod -n security-demo -- touch /test-file
# kubectl exec -it restricted-secure-pod -n security-demo -- touch /test-file  # Should fail
#
# 4. Check Linux capabilities:
# kubectl exec -it insecure-pod -n security-demo -- capsh --print
# kubectl exec -it basic-secure-pod -n security-demo -- capsh --print
# kubectl exec -it restricted-secure-pod -n security-demo -- capsh --print
#
# 5. Test privilege escalation:
# kubectl exec -it insecure-pod -n security-demo -- sudo -l 2>/dev/null || echo "No sudo"
# kubectl exec -it basic-secure-pod -n security-demo -- sudo -l 2>/dev/null || echo "No sudo"
#
# 6. Check security context in pod specs:
# kubectl get pod insecure-pod -n security-demo -o yaml | grep -A20 securityContext
# kubectl get pod basic-secure-pod -n security-demo -o yaml | grep -A20 securityContext
# kubectl get pod restricted-secure-pod -n security-demo -o yaml | grep -A20 securityContext
#
# 7. Test connectivity:
# kubectl exec -it test-client -n security-demo -- nc -zv secure-service 8080
#
# 8. Check pod status and events:
# kubectl get pods -n security-demo
# kubectl describe pod restricted-secure-pod -n security-demo
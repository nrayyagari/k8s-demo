# Namespace Isolation - Multi-Tenant Security
# Demonstrate cross-namespace communication control

---
# Create multiple namespaces for multi-tenancy demo
apiVersion: v1
kind: Namespace
metadata:
  name: team-alpha
  labels:
    team: alpha
    environment: production
    network-policy: enabled

---
apiVersion: v1
kind: Namespace
metadata:
  name: team-beta
  labels:
    team: beta
    environment: production
    network-policy: enabled

---
apiVersion: v1
kind: Namespace
metadata:
  name: shared-services
  labels:
    role: shared
    environment: production
    network-policy: enabled

---
# Team Alpha application
apiVersion: apps/v1
kind: Deployment
metadata:
  name: alpha-app
  namespace: team-alpha
spec:
  replicas: 1
  selector:
    matchLabels:
      app: alpha-app
  template:
    metadata:
      labels:
        app: alpha-app
        team: alpha
    spec:
      containers:
      - name: app
        image: nginx:1.27
        ports:
        - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: alpha-service
  namespace: team-alpha
spec:
  selector:
    app: alpha-app
  ports:
  - port: 80

---
# Team Beta application
apiVersion: apps/v1
kind: Deployment
metadata:
  name: beta-app
  namespace: team-beta
spec:
  replicas: 1
  selector:
    matchLabels:
      app: beta-app
  template:
    metadata:
      labels:
        app: beta-app
        team: beta
    spec:
      containers:
      - name: app
        image: httpd:2.4
        ports:
        - containerPort: 80

---
apiVersion: v1
kind: Service
metadata:
  name: beta-service
  namespace: team-beta
spec:
  selector:
    app: beta-app
  ports:
  - port: 80

---
# Shared database service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: shared-db
  namespace: shared-services
spec:
  replicas: 1
  selector:
    matchLabels:
      app: shared-db
  template:
    metadata:
      labels:
        app: shared-db
        role: database
        access-level: shared
    spec:
      containers:
      - name: db
        image: postgres:16
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_PASSWORD
          value: "demo123"

---
apiVersion: v1
kind: Service
metadata:
  name: shared-db-service
  namespace: shared-services
spec:
  selector:
    app: shared-db
  ports:
  - port: 5432

---
# Test clients in each namespace
apiVersion: v1
kind: Pod
metadata:
  name: alpha-client
  namespace: team-alpha
  labels:
    app: test-client
    team: alpha
spec:
  containers:
  - name: client
    image: busybox:1.36
    command: ["sleep", "3600"]

---
apiVersion: v1
kind: Pod
metadata:
  name: beta-client
  namespace: team-beta
  labels:
    app: test-client
    team: beta
spec:
  containers:
  - name: client
    image: busybox:1.36
    command: ["sleep", "3600"]

---
# NETWORK POLICY: Deny all cross-namespace traffic
# Each namespace becomes isolated by default
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-cross-namespace
  namespace: team-alpha
  annotations:
    description: "Block all traffic from other namespaces"
spec:
  podSelector: {}  # Apply to all pods in team-alpha
  policyTypes:
  - Ingress
  ingress:
  # Only allow traffic from same namespace
  - from:
    - namespaceSelector:
        matchLabels:
          team: alpha

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-cross-namespace
  namespace: team-beta
  annotations:
    description: "Block all traffic from other namespaces"
spec:
  podSelector: {}  # Apply to all pods in team-beta
  policyTypes:
  - Ingress
  ingress:
  # Only allow traffic from same namespace
  - from:
    - namespaceSelector:
        matchLabels:
          team: beta

---
# NETWORK POLICY: Allow teams to access shared services
# Shared database should be accessible to both teams
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-teams-to-shared-db
  namespace: shared-services
  annotations:
    description: "Allow production teams to access shared database"
spec:
  podSelector:
    matchLabels:
      role: database
  policyTypes:
  - Ingress
  ingress:
  # Allow from team-alpha namespace
  - from:
    - namespaceSelector:
        matchLabels:
          team: alpha
    ports:
    - protocol: TCP
      port: 5432
  # Allow from team-beta namespace
  - from:
    - namespaceSelector:
        matchLabels:
          team: beta
    ports:
    - protocol: TCP
      port: 5432

---
# NETWORK POLICY: Allow same-namespace communication
# Pods within same namespace can communicate freely
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-same-namespace
  namespace: team-alpha
  annotations:
    description: "Allow free communication within team-alpha namespace"
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector: {}  # Any pod in same namespace

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-same-namespace
  namespace: team-beta
  annotations:
    description: "Allow free communication within team-beta namespace"
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector: {}  # Any pod in same namespace

# EXPLANATION:
#
# Namespace Isolation Pattern:
# 1. Each team gets their own namespace
# 2. Cross-namespace traffic is blocked by default
# 3. Shared services are explicitly accessible
# 4. Intra-namespace communication is allowed
#
# Security Benefits:
# - Team Alpha cannot access Team Beta resources
# - Shared services have controlled access
# - Blast radius limited to single namespace
# - Multi-tenant security without separate clusters
#
# Key Selector Concepts:
# - namespaceSelector: Select source namespaces
# - podSelector in rules: Select source pods
# - podSelector in spec: Select target pods (policy applies to)

# TESTING COMMANDS:
#
# 1. Deploy everything:
# kubectl apply -f 03-namespace-isolation.yaml
#
# 2. Test same-namespace communication (should work):
# kubectl exec -it alpha-client -n team-alpha -- nc -zv alpha-service 80
# kubectl exec -it beta-client -n team-beta -- nc -zv beta-service 80
#
# 3. Test cross-namespace communication (should fail):
# kubectl exec -it alpha-client -n team-alpha -- nc -zv beta-service.team-beta.svc.cluster.local 80
# kubectl exec -it beta-client -n team-beta -- nc -zv alpha-service.team-alpha.svc.cluster.local 80
#
# 4. Test shared services access (should work):
# kubectl exec -it alpha-client -n team-alpha -- nc -zv shared-db-service.shared-services.svc.cluster.local 5432
# kubectl exec -it beta-client -n team-beta -- nc -zv shared-db-service.shared-services.svc.cluster.local 5432
#
# 5. View policies across namespaces:
# kubectl get networkpolicy -A
# kubectl describe networkpolicy allow-teams-to-shared-db -n shared-services
#
# 6. Check namespace labels:
# kubectl get namespaces --show-labels
#
# 7. Test DNS resolution (should work - egress not restricted):
# kubectl exec -it alpha-client -n team-alpha -- nslookup beta-service.team-beta.svc.cluster.local
# kubectl exec -it alpha-client -n team-alpha -- nslookup shared-db-service.shared-services.svc.cluster.local
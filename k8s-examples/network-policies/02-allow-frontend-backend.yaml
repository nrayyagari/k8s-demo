# Allow Frontend to Backend Communication
# Building on deny-all foundation with specific allow rules

---
# Prerequisites: Run 01-deny-all-ingress.yaml first
# This adds selective allow rules on top of default deny

---
# NETWORK POLICY: Allow frontend pods to access backend pods
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: secure-demo
  annotations:
    description: "Allow frontend tier to communicate with backend tier"
    depends-on: "deny-all-ingress policy must exist first"
spec:
  # Apply to backend pods (the target/destination)
  podSelector:
    matchLabels:
      tier: backend
  
  policyTypes:
  - Ingress
  
  ingress:
  # Allow traffic FROM frontend pods
  - from:
    - podSelector:
        matchLabels:
          tier: frontend
    ports:
    - protocol: TCP
      port: 80

---
# NETWORK POLICY: Allow test client to access frontend
# Useful for testing and demonstration
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-test-to-frontend
  namespace: secure-demo
  annotations:
    description: "Allow test client to access frontend for demonstration"
spec:
  # Apply to frontend pods
  podSelector:
    matchLabels:
      tier: frontend
  
  policyTypes:
  - Ingress
  
  ingress:
  # Allow traffic FROM test client
  - from:
    - podSelector:
        matchLabels:
          role: testing
    ports:
    - protocol: TCP
      port: 80

---
# Additional demo pod to show frontend-backend communication
apiVersion: v1
kind: Pod
metadata:
  name: frontend-client
  namespace: secure-demo
  labels:
    app: frontend-client
    tier: frontend
spec:
  containers:
  - name: client
    image: busybox:1.36
    command: ["sleep", "3600"]

# EXPLANATION:
#
# Network Policy Rules Logic:
# 1. deny-all-ingress (from previous file) blocks ALL traffic
# 2. allow-frontend-to-backend permits frontend → backend
# 3. allow-test-to-frontend permits test-client → frontend
#
# Traffic Flow Allowed:
# test-client → frontend ✅ (explicit allow)
# frontend → backend ✅ (explicit allow)
# test-client → backend ❌ (no rule, denied by default)
# backend → frontend ❌ (no rule, denied by default)
#
# Key Concepts:
# - podSelector in 'spec' = TARGET pods (who receives traffic)
# - podSelector in 'from' = SOURCE pods (who sends traffic)
# - Multiple NetworkPolicies are additive (OR logic)
# - Must specify both source selector AND ports

# TESTING COMMANDS:
#
# 1. Ensure previous deny-all policy is applied:
# kubectl get networkpolicy deny-all-ingress -n secure-demo
#
# 2. Apply this policy:
# kubectl apply -f 02-allow-frontend-backend.yaml
#
# 3. Test allowed connections:
# 
# Test client → frontend (should work):
# kubectl exec -it test-client -n secure-demo -- nc -zv web-app-service 80
# kubectl exec -it test-client -n secure-demo -- wget -qO- http://web-app-service --timeout=5
#
# Frontend → backend (should work):
# kubectl exec -it frontend-client -n secure-demo -- nc -zv api-server-service 80
# kubectl exec -it frontend-client -n secure-demo -- wget -qO- http://api-server-service --timeout=5
#
# 4. Test denied connections:
#
# Test client → backend (should fail):
# kubectl exec -it test-client -n secure-demo -- nc -zv api-server-service 80
# kubectl exec -it test-client -n secure-demo -- wget -qO- http://api-server-service --timeout=5
#
# Backend → frontend (should fail - no reverse rule):
# kubectl exec -it api-server-<pod-name> -n secure-demo -- nc -zv web-app-service 80
#
# 5. View all network policies:
# kubectl get networkpolicy -n secure-demo
# kubectl describe networkpolicy allow-frontend-to-backend -n secure-demo
#
# 6. Check pod labels (for debugging):
# kubectl get pods -n secure-demo --show-labels
#
# 7. Test with wrong labels (should fail):
# Create a pod with different labels and test - it won't match selectors